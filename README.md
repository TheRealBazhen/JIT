# JIT compiler
Completed by Andrei Bazhenov for CAOS and formal expressions cources.

Build and run:
```bash
mkdir build
cd build
cmake .. -DCMAKE_C_COMPILER=arm-linux-gnueabi-gcc -DCMAKE_CXX_COMPILER=arm-linux-gnueabi-g++
qemu-arm -L $LINARO_SYSROOT ./JIT
```

Описание алгоритма:
1. Разбиение входного выражения на токены (число, операция, переменная, функция).
2. Перевод полученного набора токенов в постфиксную запись (ПОЛИЗ) при помощи алгоритма Дейкстры (модернизированного для обрабоки функций многих переменных):
    1. Заводим стек операций.
    2. Если очередной элемент - число или переменная, то сразу добавляем его в результирующее выражение.
    3. Если очередной элемент - открывающая скобка, то добавляем её на стек операций.
    4. Если очередной элемент - закрывающая скобка, то скидываем все элементы со стека операций до ближайшей открывающей скобки в результирущее выражение. Если на вершине стека лежит функциональный символ, также добавляем его в результирующее выражение.
    5. Если очередной элемент - запятая, то скидываем все элементы со стека операций до ближайшей открывающей скобки, скобку оставляем на стеке.
    6. Если очередной элемент - функциональный символ, то добавляем его на стек операций.
    7. Если очередной элемент - бинарная операция, то скидываем все элементы со стека операций до ближайшей открывающей скобки или операции с меньшим приоритетом, текущую операцию добавляем на стек.
    8. Обнаружение унарного минуса можно произвести следующим образом: если очередной элемент - минус и перед ним была разобрана открывающая скобка (или это - первая операция), то этот минус - унарный. 
3. Разбор полувшегося выражения производим стандарнтным алгоритмом, используя стек ассемблера.
